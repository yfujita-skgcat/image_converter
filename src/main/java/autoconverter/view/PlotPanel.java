/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PlotPanel.java
 *
 * Created on 2009/08/27, 12:37:03
 */
package autoconverter.view;

import ij.ImagePlus;
import ij.process.ImageProcessor;
import java.awt.Graphics;
import java.io.File;
import java.util.logging.Logger;
import autoconverter.controller.AutoConverterUtils;
import autoconverter.controller.PlotPanelMediator;

/**
 *
 * @author yfujita
 */
public class PlotPanel extends javax.swing.JPanel implements PlotPanelMediator {

  private ImageProcessor ip;
  private int[] stat;
  private int[] scaled_stat;
  private static Logger logger = AutoConverterUtils.getLogger();
  private ImagePlus imp;
  private int original_max; // mean 0-4095
  private int scaled_max; // map 4096 to 1024 (4 to 1)
  private int mag;
  private int x_width = 0;
  private int y_height = 0;
  private int x_mid = 0;
  private int y_mid = 0;
  private int x_init = 0;
  private int y_init = 0;
  private int y_max = 0;
  private int lowLimit = 0;
  private int highLimit = 4095;
  private int scaled_low_limit = 0;
  private int scaled_high_limit = 4095;
  public static final int X_MARGIN = 30;
  public static final int Y_MARGIN = 30;

  /** Creates new form PlotPanel */
  public PlotPanel() {
    initComponents();
    original_max = 4096;
    //File _f1 = new File("/home/yfujita/work/2009/experiment/data/tmp/A1--W00001--P00001--Z00000--T00000--yfujita-BF-10x.tif");
    //File _f2 = new File("/home/yfujita/jst/2009/experiment/data/tmp/A1--W00001--P00001--Z00000--T00000--yfujita-BF-10x.tif");
    //ImagePlus _imp = null;
    //if (_f1.canRead()) {
    //  _imp = new ImagePlus(_f1.getAbsolutePath());
    //} else if (_f2.canRead()) {
    //  _imp = new ImagePlus(_f2.getAbsolutePath());
    //} else {
    //  logger.severe("File not found!!");
    //  System.exit(2);
    //}
    //this.setImp(_imp);
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
        // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
        private void initComponents() {

                javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
                this.setLayout(layout);
                layout.setHorizontalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 400, Short.MAX_VALUE)
                );
                layout.setVerticalGroup(
                        layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 300, Short.MAX_VALUE)
                );
        }// </editor-fold>//GEN-END:initComponents

  /**
   * mag などのfieldを計算してHistgramをアップデートする.
   */
  public void updateHistgram(){
    int _width = this.getWidth() - PlotPanel.X_MARGIN;
    int _height = this.getHeight() - PlotPanel.Y_MARGIN;
    //logger.fine("getWidth() =" + this.getWidth());
    //logger.fine("getWidth() - PlotPanel.X_MARGIN =" + _width);
    if (_width < 512) {
      _width = 256;
    } else if (_width < 1024) {
      _width = 512;
    } else {
      for (; _width > 255; _width--) {
        if (((this.original_max) % _width) == 0) {
          break;
        }
      }
    }

    this.x_mid = _width / 2;
    this.y_mid = _height / 2;
    this.x_init = (this.getWidth() - _width) / 2;
    this.y_init = PlotPanel.Y_MARGIN / 2;

    /*
     * To reduce calculation, I added this code.
     * However, init drawing false.
     */
    //if (this.x_width == _width) {
    //  logger.fine("this.x_width == " + _width);
    //  this.repaint();
    //  return;
    //}

    this.x_width = _width;
    this.y_height = _height;

    //logger.fine("original_max=" + original_max);
    mag = original_max / _width;
    //logger.fine("mag=" + mag);
    //logger.fine("_width=" + _width);

    if(stat == null){ // no image specified
      return;
    }

    this.scaled_stat = new int[_width];


    int _intensity_sum = 0;
    this.y_max = 0;
    for (int i = 0; i < original_max; i++) {
      _intensity_sum += stat[i];
      if ((i % mag) == mag - 1) {
        //logger.fine("i/mag=" + (i/mag));
        //logger.fine("scaled_stat[i/mag]=" + _intensity_sum);
        scaled_stat[i / mag] = _intensity_sum;
        if (_intensity_sum > this.y_max) {
          this.y_max = _intensity_sum;
        }
        _intensity_sum = 0;
      }
    }

    //this.repaint();

  }

  /**
   * プロットエリアのx軸最大値を指定する.
   * @param max 
   */
  public void setOriginalMax(int max){
	  original_max = max;
  }

  @Override
  public void paintComponent(Graphics g) {
    super.paintComponent(g);
    //logger.fine("paintComponent");

    this.updateHistgram();

    g.drawRect(this.x_init, this.y_init, x_width, y_height); // draw square
    if(this.imp == null ){ // no image specified
      return;
    }
    //logger.fine(imp.getTitle());



    this.scaled_low_limit = this.getLowLimit() / mag;
    this.scaled_high_limit = this.getHighLimit() / mag;
    if (this.stat == null) {
      return;
    }
    //logger.fine("width = " + x_width);
    //logger.fine("height = " + y_height);
    if (this.y_max > this.y_height) {
      for (int i = 0; i < this.scaled_stat.length; i++) {
        g.drawLine(this.x_init + i, this.y_init + this.y_height - scaled_stat[i] * y_height / this.y_max, this.x_init + i, this.y_init + this.y_height);
      }
    } else {
      for (int i = 0; i < this.scaled_stat.length; i++) {
        g.drawLine(this.x_init + i, this.y_init + this.y_height - scaled_stat[i] , this.x_init + i, this.y_init + this.y_height);
      }
    }
    // low
    g.drawLine(this.x_init + this.scaled_low_limit, this.y_init, this.x_init + this.scaled_low_limit, this.y_init + this.y_height);
    // high
    g.drawLine(this.x_init + this.scaled_high_limit, this.y_init, this.x_init + this.scaled_high_limit, this.y_init + this.y_height);



  //for (int i = 0; i < width; i++) {
  //  osg.drawLine(i, HEIGHT, i, HEIGHT - ((int) (HEIGHT * histogram[i]) / hmax));
  //}


  //int x1, y1, x2, y2;
  /*
  double scale = (double) WIDTH / (defaultMax - defaultMin);
  double slope = 0.0;
  if (max != min) {
  slope = HEIGHT / (max - min);
  }
  if (min >= defaultMin) {
  x1 = (int) (scale * (min - defaultMin));
  y1 = HEIGHT;
  } else {
  x1 = 0;
  if (max > min) {
  y1 = HEIGHT - (int) ((defaultMin - min) * slope);
  } else {
  y1 = HEIGHT;
  }
  }
  if (max <= defaultMax) {
  x2 = (int) (scale * (max - defaultMin));
  y2 = 0;
  } else {
  x2 = WIDTH;
  if (max > min) {
  y2 = HEIGHT - (int) ((defaultMax - min) * slope);
  } else {
  y2 = 0;
  }
  }
  if (histogram != null) {
  if (os == null && hmax != 0) {
  os = createImage(WIDTH, HEIGHT);
  osg = os.getGraphics();
  osg.setColor(Color.white);
  osg.fillRect(0, 0, WIDTH, HEIGHT);
  osg.setColor(color);
  for (int i = 0; i < WIDTH; i++) {
  osg.drawLine(i, HEIGHT, i, HEIGHT - ((int) (HEIGHT * histogram[i]) / hmax));
  }
  osg.dispose();
  }
  if (os != null) {
  g.drawImage(os, 0, 0, this);
  }
  } else {
  g.setColor(Color.white);
  g.fillRect(0, 0, WIDTH, HEIGHT);
  }
  g.setColor(Color.black);
  g.drawLine(x1, y1, x2, y2);
  g.drawLine(x2, HEIGHT - 5, x2, HEIGHT);
  g.drawRect(0, 0, WIDTH, HEIGHT);
   */
  }

  /**
   * @return the imp
   */
  public ImagePlus getImp() {
    return imp;
  }

  /**
   * @param imp the imp to set
   */
  public synchronized void setImp(ImagePlus imp) {
    if(imp == null){
      return;
    }
    this.imp = imp;
    if (imp.getType() != ImagePlus.GRAY16 && imp.getType() != ImagePlus.GRAY8 && imp.getType() != ImagePlus.GRAY32) {
      throw new IllegalArgumentException("imp.getType() != ImagePlus.GRAY16");
    }
    this.ip = imp.getProcessor();
    this.stat = this.ip.getHistogram();
    if(original_max > stat.length){
	    int[] tmp = this.stat;
	    this.stat = new int[original_max];
	    for(int j=0; j < original_max; j++){
		    if(j < tmp.length){
			    this.stat[j] = tmp[j];
		    } else {
			    this.stat[j] = 0;
		    }
	    }
	    original_max = stat.length;
    }
    scaled_stat = new int[scaled_max];

    // remap
    for (int i = 0; i < scaled_max; i++) {
      //scaled_stat[i] = original_max[i*mag] + original_max[i*mag+1] + original_max[i*mag+2] + original_max[i*mag+3];
      scaled_stat[i] = stat[i * mag] + stat[i * mag + 1] + stat[i * mag + 2] + stat[i * mag + 3];
    }
  }

  /**
   * @return the low_limit
   */
  public int getLowLimit() {
    return lowLimit;
  }

  /**
   * @param low_limit the low_limit to set
   */
  public void setLowLimit(int low_limit) {
    int _oldValue = this.lowLimit;
    this.lowLimit = low_limit;
    this.firePropertyChange("lowLimit", _oldValue, this.lowLimit);
    this.repaint();
  }

  /**
   * @return the highLimit
   */
  public int getHighLimit() {
    return highLimit;
  }

  /**
   * @param highLimit the highLimit to set
   */
  public void setHighLimit(int highLimit) {
    int _oldValue = this.highLimit;
    this.highLimit = highLimit;
    this.firePropertyChange("highLimit", _oldValue, this.highLimit);
    this.repaint();
  }
        // Variables declaration - do not modify//GEN-BEGIN:variables
        // End of variables declaration//GEN-END:variables
}
